<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Dart Legacy: Neon Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@19.0.0",
    "react-dom/client": "https://esm.sh/react-dom@19.0.0/client",
    "lucide-react": "https://esm.sh/lucide-react@0.460.0",
    "@google/genai": "https://esm.sh/@google/genai@^1.34.0",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&family=Orbitron:wght@400;900&display=swap');
      
      body {
        font-family: 'Fredoka', sans-serif;
        margin: 0; padding: 0;
        background-color: #020617;
        color: white;
        overflow: hidden;
        user-select: none;
        touch-action: none;
        width: 100vw; height: 100vh;
      }

      #root { width: 100%; height: 100%; }

      .title-font { font-family: 'Orbitron', sans-serif; }

      .glitch { position: relative; display: inline-block; }
      .glitch::before, .glitch::after {
        content: attr(data-text); position: absolute;
        top: 0; left: 0; width: 100%; height: 100%; opacity: 0.8;
      }
      .glitch::before { color: #22d3ee; z-index: -1; animation: glitch-anim 3s infinite linear alternate-reverse; }
      .glitch::after { color: #f43f5e; z-index: -2; animation: glitch-anim2 2s infinite linear alternate-reverse; }

      @keyframes glitch-anim {
        0% { transform: translate(0); }
        20% { transform: translate(-2px, 2px); }
        40% { transform: translate(-2px, -2px); }
        60% { transform: translate(2px, 2px); }
        80% { transform: translate(2px, -2px); }
        100% { transform: translate(0); }
      }
      @keyframes glitch-anim2 {
        0% { transform: translate(0); }
        20% { transform: translate(2px, -2px); }
        40% { transform: translate(2px, 2px); }
        60% { transform: translate(-2px, -2px); }
        80% { transform: translate(-2px, 2px); }
        100% { transform: translate(0); }
      }

      .heart-pulse {
        animation: heart-pulse 1.2s infinite ease-in-out;
      }
      @keyframes heart-pulse {
        0%, 100% { transform: scale(1); filter: drop-shadow(0 0 5px #f43f5e); }
        50% { transform: scale(1.15); filter: drop-shadow(0 0 15px #f43f5e); }
      }

      @keyframes neon-pulse-cyan {
        0%, 100% { filter: drop-shadow(0 0 10px rgba(0, 247, 255, 0.3)); }
        50% { filter: drop-shadow(0 0 30px rgba(0, 247, 255, 0.6)); }
      }
      .neon-pulse-cyan { animation: neon-pulse-cyan 3s infinite ease-in-out; }

      .fade-quote {
        animation: fade-quote 10s infinite ease-in-out;
      }
      @keyframes fade-quote {
        0%, 100% { opacity: 0; transform: translateY(15px); }
        20%, 80% { opacity: 0.6; transform: translateY(0); }
      }

      .spin-slow {
        animation: spin-slow 20s linear infinite;
      }
      @keyframes spin-slow {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }

      .watermark {
        position: absolute;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        pointer-events: none;
        font-family: 'Orbitron', sans-serif;
        font-size: 10px;
        letter-spacing: 0.6em;
        opacity: 0.25;
        color: white;
        text-transform: uppercase;
        z-index: 100;
      }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import ReactDOM from 'react-dom/client';
        import { 
          Target, Trophy, RotateCcw, Heart, Quote, Volume2, VolumeX, Crosshair, ShieldCheck, Activity
        } from 'lucide-react';

        const GameState = { MENU: 'MENU', PLAYING: 'PLAYING', GAME_OVER: 'GAME_OVER', LEVEL_COMPLETE: 'LEVEL_COMPLETE' };
        
        const CONFIG = { 
            TARGET_RADIUS: 115, 
            KNIFE_WIDTH: 15, 
            KNIFE_HEIGHT: 85, 
            COLLISION: 0.18, 
            SPEED: 2800 
        };

        const QUOTES = [
          "Precision is the silent architect of victory.",
          "A calm mind guides the sharpest throw.",
          "See the center, be the center.",
          "Focus is your only anchor in the neon chaos.",
          "The dart follows your vision, not your hand.",
          "One breath, one vision, one strike."
        ];

        class MusicEngine {
          constructor() {
            this.ctx = null;
            this.masterGain = null;
            this.isStarted = false;
            this.tempo = 120;
            this.nextNoteTime = 0;
            this.currentBeat = 0;
          }
          init() {
            if (this.ctx) return;
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.12;
            this.masterGain.connect(this.ctx.destination);
          }
          start() {
            if (this.isStarted) return;
            this.init();
            this.isStarted = true;
            this.nextNoteTime = this.ctx.currentTime;
            this.scheduler();
          }
          scheduler() {
            while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
              this.scheduleBeat(this.nextNoteTime);
              this.nextNoteTime += 60 / (this.tempo * 2);
              this.currentBeat++;
            }
            this.schedulerInterval = setTimeout(() => this.scheduler(), 25);
          }
          scheduleBeat(time) {
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.type = 'square';
            const pattern = [55, 0, 82, 55, 110, 0, 82, 0];
            const freq = pattern[this.currentBeat % pattern.length];
            if (freq > 0) {
              osc.frequency.setValueAtTime(freq, time);
              g.gain.setValueAtTime(0, time);
              g.gain.linearRampToValueAtTime(0.2, time + 0.02);
              g.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
              osc.connect(g);
              g.connect(this.masterGain);
              osc.start(time);
              osc.stop(time + 0.2);
            }
          }
          setMuted(muted) {
            if (!this.masterGain) return;
            this.masterGain.gain.setTargetAtTime(muted ? 0 : 0.12, this.ctx.currentTime, 0.1);
          }
        }

        const music = new MusicEngine();

        const NeonLogo = ({ size = 200, interactive = false }) => (
          <div className={`relative flex items-center justify-center neon-pulse-cyan ${interactive ? 'animate-pulse' : ''}`} style={{ width: size, height: size }}>
            <div className="absolute inset-0 spin-slow">
                <svg viewBox="0 0 200 200" className="w-full h-full opacity-30">
                  <circle cx="100" cy="100" r="92" fill="none" stroke="#00f7ff" strokeWidth="1" strokeDasharray="5 10" />
                </svg>
            </div>
            <Crosshair size={size * 0.6} className="text-cyan-400 drop-shadow-[0_0_15px_rgba(0,247,255,0.6)]" />
          </div>
        );

        const DartIconHUD = ({ active }) => (
          <div className={`transition-all duration-300 ${active ? 'scale-110 opacity-100 drop-shadow-[0_0_8px_rgba(255,255,255,0.5)]' : 'scale-75 opacity-10 grayscale'}`}>
            <svg width="24" height="40" viewBox="0 0 24 40" fill="none">
              <path d="M12 32C12 32 19 24 19 16C19 8 16 4 12 4C8 4 5 8 5 16C5 24 12 32 12 32Z" fill={active ? "#ff0080" : "#475569"}/>
              <path d="M11.2 0H12.8V40H11.2V0Z" fill={active ? "white" : "#475569"} />
            </svg>
          </div>
        );

        const GameCanvas = ({ gameState, level, onHit, onFail, onLevelComplete, onDartsUpdate }) => {
          const canvasRef = useRef(null);
          const rotationRef = useRef(0);
          const velocityRef = useRef(0.03);
          const knivesRef = useRef([]);
          const obstaclesRef = useRef([]);
          const activeRef = useRef(null);
          const fallingKnivesRef = useRef([]);
          const knivesLeftRef = useRef(5);
          const frameIdRef = useRef(0);
          const lastTimeRef = useRef(performance.now());

          const drawDart = (ctx, isFailed = false, rotationAngle = 0) => {
            const w = CONFIG.KNIFE_WIDTH, h = CONFIG.KNIFE_HEIGHT;
            ctx.save();
            ctx.rotate(rotationAngle);
            if (isFailed) { ctx.shadowBlur = 30; ctx.shadowColor = "#f43f5e"; } 
            else { ctx.shadowBlur = 15; ctx.shadowColor = "#00f7ff"; }
            
            ctx.fillStyle = isFailed ? "#7f1d1d" : "#cbd5e1"; 
            ctx.beginPath(); ctx.moveTo(-0.5, h*0.1); ctx.lineTo(0, h/2 + 25); ctx.lineTo(0.5, h*0.1); ctx.fill();
            ctx.fillStyle = "#334155"; ctx.beginPath(); ctx.roundRect(-w/2, -h/2, w, h*0.65, 4); ctx.fill();
            ctx.fillStyle = isFailed ? "#f43f5e" : "#ff0080"; 
            ctx.beginPath(); ctx.moveTo(0, -h/2 + 10); ctx.lineTo(-w*2.5, -h/2 - 25); ctx.lineTo(0, -h/2 - 8); ctx.lineTo(w*2.5, -h/2 - 25); ctx.closePath(); ctx.fill();
            ctx.restore();
          };

          const throwKnife = useCallback((e) => {
            if (e && e.cancelable) e.preventDefault();
            if (activeRef.current || (gameState !== GameState.PLAYING) || knivesLeftRef.current <= 0) return;
            activeRef.current = { y: canvasRef.current.height - 180 };
            knivesLeftRef.current--;
            onDartsUpdate(knivesLeftRef.current);
          }, [gameState, onDartsUpdate]);

          useEffect(() => {
            const handleKey = (e) => (e.code === 'Space' || e.code === 'ArrowUp') && (e.preventDefault(), throwKnife());
            window.addEventListener('keydown', handleKey); return () => window.removeEventListener('keydown', handleKey);
          }, [throwKnife]);

          useEffect(() => {
            if (canvasRef.current) {
                const centerX = canvasRef.current.width / 2;
                const centerY = canvasRef.current.height / 4 + 40;
                knivesRef.current.forEach(k => {
                    const worldAngle = k.angle + rotationRef.current;
                    fallingKnivesRef.current.push({
                        x: centerX + Math.cos(worldAngle - Math.PI/2) * CONFIG.TARGET_RADIUS,
                        y: centerY + Math.sin(worldAngle - Math.PI/2) * CONFIG.TARGET_RADIUS,
                        vx: (Math.random() - 0.5) * 50, vy: -15 - Math.random() * 20, 
                        rotation: worldAngle, vRotation: (Math.random()-0.5)*0.4
                    });
                });
            }
            knivesRef.current = []; obstaclesRef.current = [];
            knivesLeftRef.current = 5; onDartsUpdate(5);
            rotationRef.current = 0; velocityRef.current = 0.03 + level * 0.012;
            if (level > 2) {
              const obsCount = Math.min(level - 2, 5);
              for(let i=0; i<obsCount; i++) obstaclesRef.current.push({ angle: (Math.PI * 2 * i) / obsCount + (Math.random() * 0.5) });
            }
          }, [level]);

          const update = (time) => {
            const canvas = canvasRef.current; if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const centerX = width / 2, centerY = height / 4 + 40;
            const dt = (time - lastTimeRef.current) / 1000; lastTimeRef.current = time;

            ctx.clearRect(0, 0, width, height);
            if (gameState === GameState.PLAYING) rotationRef.current += velocityRef.current * (dt * 60);

            for (let i = fallingKnivesRef.current.length - 1; i >= 0; i--) {
                const k = fallingKnivesRef.current[i];
                k.x += k.vx; k.y += k.vy; k.vy += 2.2; k.rotation += k.vRotation;
                ctx.save(); ctx.translate(k.x, k.y); drawDart(ctx, true, k.rotation); ctx.restore();
                if (k.y > height + 250) fallingKnivesRef.current.splice(i, 1);
            }

            ctx.save(); ctx.translate(centerX, centerY); ctx.rotate(rotationRef.current);
            const radius = CONFIG.TARGET_RADIUS;
            ctx.strokeStyle = "#0ea5e9"; ctx.lineWidth = 8; ctx.beginPath(); ctx.arc(0, 0, radius + 12, 0, Math.PI * 2); ctx.stroke();
            for (let i = 0; i < 20; i++) {
                ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0, 0, radius, (i*Math.PI*2)/20, ((i+1)*Math.PI*2)/20);
                ctx.fillStyle = i % 2 === 0 ? "#1e293b" : "#020617"; ctx.fill();
            }
            knivesRef.current.forEach(k => { 
                ctx.save(); ctx.rotate(k.angle + Math.PI/2); ctx.translate(0, -radius); drawDart(ctx, k.failed); ctx.restore(); 
            });
            obstaclesRef.current.forEach(obs => { 
                ctx.save(); ctx.rotate(obs.angle + Math.PI/2); ctx.translate(0, -radius - 12); 
                ctx.shadowBlur = 20; ctx.shadowColor = "#ff0033"; ctx.fillStyle = "#ff0033"; ctx.fillRect(-24, -12, 48, 24); ctx.restore(); 
            });
            ctx.restore();

            if (activeRef.current) {
              activeRef.current.y -= CONFIG.SPEED * dt;
              const impactY = centerY + radius;
              if (activeRef.current.y - 45 <= impactY) {
                let impactAngle = (Math.PI/2) - rotationRef.current; 
                impactAngle = (impactAngle % (Math.PI * 2)); if (impactAngle < 0) impactAngle += Math.PI * 2;
                
                const hitDart = knivesRef.current.some(k => { 
                    let d = Math.abs(k.angle - impactAngle); return (d > Math.PI ? Math.PI*2-d : d) < CONFIG.COLLISION; 
                });
                const hitObs = obstaclesRef.current.some(obs => { 
                    let d = Math.abs(obs.angle - impactAngle); return (d > Math.PI ? Math.PI*2-d : d) < 0.25; 
                });

                if (hitDart) {
                   onFail();
                   fallingKnivesRef.current.push({ x: centerX, y: activeRef.current.y, vx: (Math.random()-0.5)*60, vy: -25, rotation: Math.PI, vRotation: (Math.random()-0.5)*0.8 });
                   activeRef.current = null;
                } else if (hitObs) {
                   onFail();
                   knivesRef.current.push({ angle: impactAngle, failed: true });
                   activeRef.current = null;
                   if(knivesLeftRef.current === 0) setTimeout(onLevelComplete, 500);
                } else {
                   knivesRef.current.push({ angle: impactAngle, failed: false }); 
                   onHit(); activeRef.current = null;
                   if(knivesLeftRef.current === 0) setTimeout(onLevelComplete, 500);
                }
              } else { ctx.save(); ctx.translate(centerX, activeRef.current.y); ctx.rotate(Math.PI); drawDart(ctx); ctx.restore(); }
            }

            if (knivesLeftRef.current > 0 && gameState === GameState.PLAYING) {
              ctx.save(); ctx.translate(centerX, height - 180); ctx.rotate(Math.PI); drawDart(ctx); ctx.restore();
            }

            frameIdRef.current = requestAnimationFrame(update);
          };

          useEffect(() => {
            const resize = () => { if (canvasRef.current) { canvasRef.current.width = window.innerWidth; canvasRef.current.height = window.innerHeight; } };
            window.addEventListener('resize', resize); resize();
            frameIdRef.current = requestAnimationFrame(update);
            return () => { cancelAnimationFrame(frameIdRef.current); window.removeEventListener('resize', resize); };
          }, [gameState]);

          return <canvas ref={canvasRef} className="block w-full h-full touch-none" onPointerDown={throwKnife} />;
        };

        const App = () => {
          const [gameState, setGameState] = useState(GameState.MENU);
          const [score, setScore] = useState(0);
          const [level, setLevel] = useState(1);
          const [lives, setLives] = useState(3);
          const [darts, setDarts] = useState(5);
          const [isMuted, setIsMuted] = useState(false);
          const [currentQuote, setCurrentQuote] = useState(QUOTES[0]);

          useEffect(() => {
            const interval = setInterval(() => {
              setCurrentQuote(QUOTES[Math.floor(Math.random() * QUOTES.length)]);
            }, 10000);
            return () => clearInterval(interval);
          }, []);
          
          return (
            <div className="relative w-full h-full text-white overflow-hidden bg-slate-950">
              <div className="watermark">J.M.O 2025</div>
              
              {(gameState === GameState.PLAYING || gameState === GameState.LEVEL_COMPLETE || gameState === GameState.GAME_OVER) && (
                <GameCanvas 
                  gameState={gameState} level={level}
                  onHit={()=>setScore(s=>s+1)} 
                  onFail={()=>{ setLives(l=>l-1); if(lives<=1) setGameState(GameState.GAME_OVER); }} 
                  onLevelComplete={()=>{ if(level < 20) setLevel(l=>l+1); else setGameState(GameState.LEVEL_COMPLETE); }} 
                  onDartsUpdate={setDarts}
                />
              )}
              
              {gameState === GameState.PLAYING && (
                <div className="absolute inset-0 pointer-events-none p-8 flex flex-col justify-between z-10">
                  <div className="flex justify-between items-start">
                    <div className="flex flex-col gap-5">
                        <div className="bg-black/60 backdrop-blur-xl p-6 rounded-[2.5rem] border border-white/5 shadow-2xl">
                            <div className="text-6xl font-black title-font text-cyan-400 drop-shadow-[0_0_15px_rgba(34,211,238,0.6)]">{score}</div>
                            <div className="text-[10px] text-white/40 font-bold uppercase tracking-[0.5em] mt-2 flex items-center gap-2">
                                <Activity size={12} className="text-cyan-500" /> SYSTEM SCORE
                            </div>
                        </div>
                        <div className="flex flex-col gap-2 ml-4">
                            <div className="flex gap-2">
                                {[...Array(3)].map((_, i) => (
                                    <Heart key={i} size={32} className={i < lives ? "text-rose-500 fill-rose-500 heart-pulse" : "text-slate-900"} />
                                ))}
                            </div>
                            <div className="text-[10px] font-black text-rose-500/50 uppercase tracking-widest flex items-center gap-2">
                                <ShieldCheck size={12} /> PROTOCOL STABILITY
                            </div>
                        </div>
                    </div>
                    <div className="text-right flex flex-col items-end gap-6 pointer-events-auto">
                      <div className="bg-black/60 backdrop-blur-xl p-5 rounded-[2.5rem] border border-white/5 shadow-2xl flex flex-col items-end">
                         <div className="flex items-center gap-4">
                            <NeonLogo size={48} interactive />
                            <span className="text-4xl font-black text-white title-font">{`S-${level.toString().padStart(2,'0')}`}</span>
                         </div>
                         <div className="text-[9px] text-cyan-400/40 font-black tracking-[0.4em] uppercase mt-2">MECHANICS & PROTOCOL: ACTIVE</div>
                      </div>
                      <button onClick={() => { setIsMuted(!isMuted); music.setMuted(!isMuted); }} className="p-5 rounded-[1.5rem] bg-white/5 border border-white/10 hover:bg-white/10 transition-all shadow-xl">
                        {isMuted ? <VolumeX className="text-rose-500" size={28} /> : <Volume2 className="text-cyan-400" size={28} />}
                      </button>
                    </div>
                  </div>
                  
                  <div className="absolute bottom-[22%] left-0 w-full flex justify-center pointer-events-none px-12 text-center">
                    <p className="fade-quote text-cyan-400/50 font-black italic text-2xl title-font uppercase tracking-tighter leading-tight max-w-2xl">
                      "{currentQuote}"
                    </p>
                  </div>

                  <div className="flex flex-col-reverse gap-4 ml-10 mb-20">
                     {[...Array(5)].map((_, i) => ( <DartIconHUD key={i} active={i < darts} /> ))}
                  </div>
                </div>
              )}

              {gameState !== GameState.PLAYING && (
                <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-slate-950/90 backdrop-blur-3xl p-8 text-center overflow-y-auto">
                  {gameState === GameState.MENU && (
                    <div className="flex flex-col items-center animate-in fade-in duration-1000">
                       <div className="mb-12"><NeonLogo size={220} /></div>
                       <h1 className="glitch text-7xl md:text-[9rem] font-black title-font text-white uppercase leading-none mb-12 tracking-tighter" data-text="DART LEGACY">
                          DART <span className="text-rose-500">LEGACY</span>
                       </h1>
                       <div className="bg-black/40 backdrop-blur-md p-10 rounded-[3rem] border border-white/10 mb-12 max-w-lg shadow-2xl">
                         <Quote className="mx-auto mb-6 text-rose-500/70" size={32} />
                         <p className="italic text-2xl text-slate-200 font-medium">"{currentQuote}"</p>
                       </div>
                       <button onClick={() => { music.start(); setGameState(GameState.PLAYING); }} className="bg-cyan-500 text-black px-20 py-10 rounded-full font-black text-4xl title-font hover:scale-110 shadow-[0_0_80px_rgba(6,182,212,0.5)] transition-all uppercase tracking-widest">INITIALIZE CHALLENGE</button>
                    </div>
                  )}
                  {gameState === GameState.GAME_OVER && (
                    <div className="flex flex-col items-center animate-in zoom-in duration-500">
                       <div className="bg-rose-500/10 p-12 rounded-full mb-10 border-4 border-rose-500/30 animate-pulse">
                          <Target size={120} className="text-rose-500" />
                       </div>
                       <h2 className="text-4xl md:text-5xl font-black title-font text-rose-500 mb-10 uppercase drop-shadow-[0_0_30px_rgba(244,63,94,0.6)] max-w-2xl leading-tight">
                          Game over 3 lives are finished play again?
                       </h2>
                       <button onClick={() => window.location.reload()} className="bg-emerald-500 text-black px-24 py-10 rounded-full font-black text-4xl title-font uppercase hover:scale-110 transition-all shadow-[0_0_80px_rgba(16,185,129,0.5)]"><RotateCcw size={48} className="inline mr-6" /> RELOAD CORE</button>
                    </div>
                  )}
                  {gameState === GameState.LEVEL_COMPLETE && (
                    <div className="flex flex-col items-center animate-in zoom-in duration-700">
                       <Trophy size={180} className="text-yellow-400 mb-10 animate-bounce drop-shadow-[0_0_40px_rgba(250,204,21,0.6)]" />
                       <h2 className="text-6xl md:text-8xl font-black text-white mb-6 title-font uppercase tracking-widest">LEGACY ACHIEVED</h2>
                       <button onClick={() => window.location.reload()} className="bg-cyan-500 text-black px-24 py-10 rounded-full font-black text-4xl title-font uppercase hover:scale-110 transition-all">EXTRACT DATA</button>
                    </div>
                  )}
                </div>
              )}
            </div>
          );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>